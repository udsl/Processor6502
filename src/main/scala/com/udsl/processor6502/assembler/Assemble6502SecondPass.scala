package com.udsl.processor6502.assembler

import com.typesafe.scalalogging.StrictLogging
import com.udsl.processor6502.assembler.Assemble6502FirstPass.{processClear, setAddresses, setBytes, setWords}
import com.udsl.processor6502.assembler.Assemble6502SecondPass.logger


/**
 * Second pass object - Using the the data generated by the first pass does the actual assembly.
 */
object Assemble6502SecondPass extends StrictLogging, Assemble6502PassBase :

  def assemble(tokenisedLine: TokenisedLine) : Unit =
    logger.info(s"\n\n2nd Pass ${tokenisedLine.sourceLine.lineNumber} ")
    for (token <- tokenisedLine.tokens)
      token match {
        case BlankLineToken( _, _ ) => // extends AssemblerTokenType("BlankLineToken")
          logger.info("\tBlankLineToken ")
        case CommentLineToken( _, _ ) => // extends AssemblerTokenType("CommentLineToken")
          logger.info("\tCommentLineToken ")
        case LineComment( _, _ ) => // extends AssemblerTokenType("LineComment")
          logger.info("\tLineComment ")
        case NoneCommentLine( _, _ ) => // extends AssemblerTokenType("NoneCommentLine")
          logger.info("\tNoneCommentLine ")
        case LabelToken( _, _ ) => // extends AssemblerTokenType("LabelToken")
          procesLabel(token)
        case CommandToken( _, _ ) => // extends AssemblerTokenType("CommandToken")
          assembleCommandToken(token)
        case InstructionToken( _, _ ) => // extends AssemblerTokenType("InstructionToken")
          assembleInstructionToken(token)
        case SyntaxErrorToken( _, _ ) => // extends AssemblerTokenType("SyntaxErrorToken")
          logger.info("\tSyntaxErrorToken ")
        case ClearToken( _, _ ) =>
          logger.info("\tClear Token")
          processClear(token, tokenisedLine)

        case _ => logger.error(s"unsupported case ${token.value}")
      }

  def procesLabel(token: AssemblerToken): Unit =
    logger.info("\tprocesLabel ")

  def assembleCommandToken(t: AssemblerToken): Unit =
    logger.info(s"\tassembleCommandToken '${t.value}' - ")
    t.value.toUpperCase() match
      case "ORIG" => AssembleLocation.setAssembleLoc(t.intValue)
      case "BYT" => setBytes(t.fields)
      case "WRD" => setWords(t.fields)
      case "ADDR" => setAddresses(t.fields)
      case _ => logger.info(s"\tInvalid command ${t.fields} ")

  def assembleInstructionToken(token: AssemblerToken): Unit =
    logger.info("\tassembleCommandToken ")


