package com.udsl.processor6502.assembler.version2

import com.typesafe.scalalogging.StrictLogging
import com.udsl.processor6502.Utilities.*
import com.udsl.processor6502.assembler.{AssembleLocation, AssemblePass, AssemblyData}
import com.udsl.processor6502.cpu.CpuInstructions
import com.udsl.processor6502.cpu.CpuInstructions.{getInstruction, isValidInstruction}
import com.udsl.processor6502.cpu.execution.{AddressingMode, Invalid, *}
import com.udsl.processor6502.{NumericFormatType, Utilities}

/**
 * Second pass object - Using the the data generated by the first pass does the actual assembly.
 */
class Assemble6502SecondPassV2 extends StrictLogging, AssemblePass :

  def assemble(firstPassResult: FirstPassResult) : SecondPassResult =
    logger.info(s"\n\n2nd Pass ${firstPassResult.lineNumber} ")
    // need to process all the tokens into the second pass result
    val result : SecondPassResult = SecondPassResult.apply(firstPassResult)
    for (token <- firstPassResult.tokens)
      token match {
        case BlankLineTokenV2( _ ) =>
          logger.info("\tBlankLineToken ")
        case CommentLineTokenV2( _ ) =>
          logger.info("\tCommentLineToken ")
        case LineCommentTokenV2( _, _ ) =>
          logger.info("\tLineComment ")
        case LabelTokenV2( _, _ ) =>
          procesLabel(token.asInstanceOf[LabelTokenV2])
        case CommandTokenV2( _, _ ) =>
          assembleCommand(token)
        case InstructionTokenV2( _, _ ) =>
          assembleInstruction(token.asInstanceOf[InstructionTokenV2], result.firstPassResult.tokenisedLine)
        case _ => logger.error(s"unsupported case $token")
      }
    result

  
  def procesLabel(token: LabelTokenV2): Unit =
    logger.info(s"\tprocesLabel -> $token")

  def assembleCommand(t: TokenV2): Unit =
    val command = t match {
      case c if t.isInstanceOf[CommandTokenV2] =>
        c.asInstanceOf[CommandTokenV2].command.toUpperCase

      case _ =>
        "invalid"
    }
    logger.info(s"\tassembleCommandToken '$t' - ")
    command match
      case "BYT" => setBytes(t.fields)
      case "WRD" => setWords(t.fields)
      case "ADDR" => setAddresses(t.fields)
      case "ORIG" => processOrigin(t)
      case "CLR" => () // CLR not processed during 2nd pass
      case _ => logger.info(s"\tInvalid command ${t.tokenText} ")

  def processOrigin(t: TokenV2): Unit =
    logger.info("\tOrigin Token 2nd pass")
    val value = Utilities.numericValue(t.tokenText)
    if 0 to 65535 contains value then
      AssembleLocation.setAssembleLoc(value)


  // TODO refactor
  def assembleInstruction(t: InstructionTokenV2, tl: TokenisedLineV2): TokenV2 =
    def getValue(operand: String): Option[Int] =
      if isNumeric(operand) then
        numericValue(operand)
      else // only other possibility is a label
        AssemblyData.labels.get(operand) match
          case Some((v, _)) =>
            Some(v)
          case _ =>
            //TODO report this error!
 //           addSyntaxError(SyntaxErrorRecord(s"Undefined label '$operand'", tl))
            None

    def getOperandValue: Option[Int] =
      val operand = if t.fields.head.charAt(0) == '#' then
        t.fields.head.substring(1)
      else
        t.fields.head
      getValue(operand)

    def getIndexedOperandValue: Option[Int] =
      val operand = t.fields.head.substring(0, t.fields.head.length - 2)
      getValue(operand)

    /**
     * options: (indirect), (indirect,X) or (indirect),Y
     *
     * @return
     */
    def getIndirectOperandValue: Option[Int] =
      val op1 = t.fields.head.toUpperCase.substring(1) // remove the leading '('
      if op1.substring(op1.length() - 3) == "),Y"  || op1.substring(op1.length() - 3) == ",X)" then // (indirect),Y or (indirect,X)
        getValue(op1.substring(0, op1.length() - 3))
      else
        getValue(op1.substring(0, op1.length() - 1)) // (indirect)

    /**
     * Check if the addressing mode is valid and the operand
     * @param mode the addressing mode to check
     * @return a tuble of the effective addressing mode and the optional operand.
     */
    def CheckAddressingMode(mode: AddressingMode): (AddressingMode, Option[Int]) =
      mode match {
        case Immediate =>
          if t.fields.head.charAt(0) != '#' then
            return (AddressingModeSyntaxError("missing #"), None)
          if CpuInstructions.isAddressingModeValid(t.mnemonic, Immediate) then
            val operandValue = getOperandValue
            if operandValue.isEmpty then
              return (AddressingModeSyntaxError("Operand is niether a number or a valid label."), None)
            if 0 to 255 contains operandValue then
              return (Immediate, Some(operandValue.get))
            else
              return (AddressingModeSyntaxError("Operand not in range 0 to 255"), None)
          (Invalid, None)

        case Absolute | ZeroPage =>
          getOperandValue match
            case Some(operandValue) =>
              if operandValue < 0 || operandValue > 65535 then
                return (AddressingModeSyntaxError("Operand not in range for absolute and ZeroPage (0 to 65535)"), None)
              if operandValue > 255 then
                if CpuInstructions.isAddressingModeValid(t.mnemonic, Absolute) then
                  return (Absolute, Some(operandValue))
              else if CpuInstructions.isAddressingModeValid(t.mnemonic, ZeroPage) then
                return (ZeroPage, Some(operandValue))
              (Invalid, None)
            case None =>
              (AddressingModeSyntaxError("Operand is niether a number or a valid label."), None)


        case ZeroPageX | AbsoluteX =>
          if !t.fields.head.toUpperCase.contains(",X") then
            return (AddressingModeSyntaxError("Syntax incorrect ',X' required"), None)
          getOperandValue match
            case Some(operandValue) =>
              if operandValue < 0 || operandValue > 65535 then
                return (AddressingModeSyntaxError("Operand not in range for absolute,x and ZeroPage,x (0 to 65535)"), None)
              if operandValue > 255 then
                if CpuInstructions.isAddressingModeValid(t.mnemonic, AbsoluteX) then
                  return (AbsoluteX, Some(operandValue))
              else if CpuInstructions.isAddressingModeValid (t.mnemonic, ZeroPageX) then
                return (ZeroPageX, Some (operandValue) )
              (Invalid, None)
            case None =>
              (AddressingModeSyntaxError("Operand is neither a number or a valid label."), None)

        case ZeroPageY | AbsoluteY =>
          if !t.fields.head.toUpperCase.contains(",Y") then
            return (AddressingModeSyntaxError("Syntax incorrect ',Y' required"), None)
          getOperandValue match
            case Some(operandValue) =>
              if operandValue < 0 || operandValue > 65535 then
                return (AddressingModeSyntaxError("Operand not in range for absolute,y and ZeroPage,y (0 to 65535)"), None)
              if operandValue > 255 then
                if CpuInstructions.isAddressingModeValid(t.mnemonic, AbsoluteY) then
                  return (AbsoluteY, Some(operandValue))
              else if CpuInstructions.isAddressingModeValid(t.mnemonic, ZeroPageY) then
                return (ZeroPageY, Some(operandValue))
              (Invalid, None)
            case None =>
              (AddressingModeSyntaxError("Operand is neither a number or a valid label."), None)


        case IndirectX =>
          if t.fields.head.toUpperCase.contains(",X)") then
            return (AddressingModeSyntaxError("Syntax incorrect ',X)' required"), None)
          if CpuInstructions.isAddressingModeValid(t.mnemonic, IndirectX) then
            getIndirectOperandValue match
              case Some(operandValue) =>
                if 0 to 255 contains operandValue then
                  return (IndirectX, Some(operandValue))
                else
                  return (AddressingModeSyntaxError("Operand not in range for 0 to 255)"), None)
              case None =>
                return (AddressingModeSyntaxError("Operand is neither a number or a valid label."), None)
          (Invalid, None)

        case IndirectY =>
          if t.fields.head.toUpperCase.contains(",Y)") then
            return (AddressingModeSyntaxError("Syntax incorrect ',Y)' required"), None)
          if CpuInstructions.isAddressingModeValid(t.mnemonic, IndirectY) then
            getIndirectOperandValue match
              case Some(operandValue) =>
                if 0 to 255 contains operandValue then
                  return (IndirectY, Some(operandValue))
                else
                  return (AddressingModeSyntaxError("Invalid value for operand"), None)
              case None =>
                return (AddressingModeSyntaxError("Operand is neither a number or a valid label."), None)
          (Invalid, None)

        case Indirect =>
          if t.fields.head.contains(",") || !t.fields.head.contains(")") then // if it has a comma then its not Indirect but it must have an ')'
            return (AddressingModeSyntaxError("Syntax incorrect brackets required but without ','"), None)
          if CpuInstructions.isAddressingModeValid(t.mnemonic, Indirect) then
            getIndirectOperandValue match
              case Some(operandValue) =>
                if operandValue < 0 || operandValue > 65535 then
                  return (AddressingModeSyntaxError("Operand not in range for Indirect (0 to 65535)"), None)
                return (Indirect, Some(operandValue))
              case None =>
                return (AddressingModeSyntaxError("Operand is neither a number or a valid label."), None)
          (Invalid, None)

        case Implied =>
          if t.fields.length == 0 && CpuInstructions.isAddressingModeValid(t.mnemonic, Implied) then
            return (Implied, None) // there is no operand
          (Invalid, None)

        case Accumulator =>
          if t.fields.isEmpty || !"A".equals(t.fields.head.toUpperCase) then
            return (AddressingModeSyntaxError("Syntax incorrect A required (for accumilator)"), None)
          if CpuInstructions.isAddressingModeValid(t.mnemonic, Accumulator) then
            return (Accumulator, None) // there is no operand
          (Invalid, None)

        case Relative =>
          // check that mode is appropriate
          if CpuInstructions.isAddressingModeValid(t.mnemonic, Relative) then
            // Target of branch can be a byte value or a label destination
            getIndirectOperandValue match
              case Some(operandValue) =>
                if isLabel(t.fields.head) then // its an address to branch to
                  // This offset should be from the following instraction because the 6502 would have increament the PC on each fetch
                  // so if we are going backwards need those extra 2 bytes bit if going wards
                  // pc is already incremented by 2 so need an offset that is 2 less.
                  val offset = operandValue - AssembleLocation.currentLocation
                  if offset < 0 && (offset - 2 > -128) then
                    return (Relative, Some(offset - 2))
                  if offset > 0 && offset > 130 then
                    return (Relative, Some(offset + 2))
                  logger.info(s"Relative address out of range ${t.mnemonic}")
                  return (Invalid, None)
                else
                  if operandValue > 0 && operandValue < 256 then
                    return (Relative, Some(operandValue))
                return (Invalid, None)
              case None =>
                (AddressingModeSyntaxError("Operand is neither a number or a valid label."), None)
          (Invalid, None)

        case _ =>
          (Invalid, None)
      }

    // assembleInstruction (t: InstructionTokenV2, tl: TokenisedLineV2): TokenV2 -- function body
    logger.info(s"assembleInstructionToken - ${t.mnemonic}")
    getInstruction(t.mnemonic) match
      case Some(cpuIns) =>
        println(cpuIns)
        InstructionTokenV2(t.mnemonic, t.fields)
      case _ =>
        //TODO
        // addSyntaxError(SyntaxErrorRecord(s"Invalid addressing mode for '${t.mnemonic}'", tl))
        SytaxErrorTokenV2(s"Invalid addressing mode for '${t.mnemonic}'", t.fields)

//    if isValidInstruction(t.mnemonic) then
//      val modeList = List(Accumulator, Immediate, Absolute, ZeroPage, ZeroPageX, ZeroPageY, AbsoluteX, AbsoluteY, IndirectX, IndirectY, Indirect, Implied, Relative)
//
//      modeList.map(CheckAddressingMode).foreach(a =>
//        a match
//          case Some(addressingMode, value) =>
//            //TODO
//            // Need details of the instruction for the disassembly byte string
//            // mnemonic, value and number bytes
//            val (opcode: Int, bytes:Int) = CpuInstructions.getInstructionOpcodeBytes(t.mnemonic, addressingMode)
//            setMemoryByte(opcode, constructSourceLine(t.mnemonic, addressingMode, (value % 256, value / 256)))
//            // now we know how long the instruction shoud be
//            bytes match
//              case 1 =>
//                // implied or accumulator so nothing else to write.
//              case 2 =>
//                // Imeadiate, zeropage etc
//                setMemoryByte(value)
//              case 3 =>
//                // Absolute
//                setMemoryAddress(value)
//              case _ =>
//                throw new Exception(s"SYSTEM ERROR INVALID BYTES FOR INSTRUCTION - ${t.mnemonic}")
//          case _ =>
//      )

  def setBytes(fields: Array[String]): Unit =
    logger.debug("setBytes")
    for (value <- fields)
      setMemoryByte(value.trim)

  def setWords(fields: Array[String]): Unit =
    logger.debug("setWords")
    for (value <- fields)
      setMemoryWord(value.trim)

  def setMemoryWord(v: String): Unit =

    if v.charAt(0).isLetter then // a label
      AssembleLocation.setMemoryWord(0x6363) // word value for 99, 99 decimal
    else
      AssembleLocation.setMemoryWord(if v.charAt(0) == '$' then
        Integer.parseInt(v.substring(1), 16)
      else
        Integer.parseInt(v))

  def setAddresses(fields: Array[String]): Unit =
    logger.debug("setAddresses")
    for (v <- fields)
      val value = v.trim
      setMemoryAddress( numericValue(value).getOrElse({
        AssemblyData.labelValue(value).getOrElse(throw new Exception(s"Invalid value address '$value'"))
      }) )

object Assemble6502SecondPassV2:
  def apply: Assemble6502SecondPassV2 =
    new Assemble6502SecondPassV2()
